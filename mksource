#!/usr/bin/perl
# {{{1 Header
###
# mksource - generate text and code from templates
#
# Copyright:
# 
# (2011) - Claudio Klingler - realtime projects -
#
# License:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
###

use Getopt::Long;
use Pod::Usage;
use POSIX qw/strftime/;

# {{{1 Argument evaluation

my $TMPLNAME = 'cpp';
my $A_VERBOSE = '';
my $A_HELP = '';
my $OUTDIR = '.';
my $A_DEBUG = '';
my $A_FORCE_OVERWRITE = '';
my $M_LIST = '';
my $M_SHOWARGS = '';


my $V_YEAR=strftime("%Y", localtime());
my $V_ISODATE=strftime("%Y-%m-%d", localtime());
my $USER=$ENV{'LOGNAME'};

my %argssettings = (
  'template|t=s' => \$TMPLNAME,
  'help|h'       => \$A_HELP,
  'verbose|v'    => \$A_VERBOSE,
  'output|o=s'   => \$OUTDIR,
  'user|u=s'     => \$USER,
  'debug|d'      => \$A_DEBUG,
  'force|f'      => \$A_FORCE_OVERWRITE,
  'list'         => \$M_LIST,
  'show_args'    => \$M_SHOWARGS,
);

GetOptions(%argssettings);

$V_SOURCE="cpp";

my $TMPLDIR="";
get_config();

# {{{1 Running mode

my $TMPLDIR=get_mksource_template_dir();

debug("TMPLDIR is $TMPLDIR");

if ($M_SHOWARGS)
{
    foreach my $argument ( keys %argssettings )
    {
        $argument =~ s/\|.*//;
        print "--$argument ";
    }
    print "\n";
    exit(0);
}

if ($M_LIST)
{
    @templates = list_templates();
    print join(" ", @templates);
    exit(0);
}

$TARGET=shift @ARGV;
pod2usage(1) if ($A_HELP);
pod2usage(2) if (!$TARGET);

my %mapping = get_file_mapping($TMPLDIR, $TMPLNAME);

while (($source, $target) = each(%mapping))
{
  debug("target before: $target");
  $target=do_substitution($target);
  debug("target after: $target");
  verbose("generating $target from $source...");
  gen_source("$target", "$source");
}

# {{{1 FUNCTIONS

# {{{2 gen_source(target, source) - generate target file from source
sub gen_source
{
  my $target = shift @_;
  my $source = shift @_;

  error("target $OUTDIR/$target already exists") if (-e "$OUTDIR/$target" && !$A_FORCE_OVERWRITE);
  open(SFILE, "$TMPLDIR/$source") || error("source file not found $TMPLDIR/$source");
  open(TFILE, ">$OUTDIR/$target") || error("could not open $OUTDIR/$target for writing");

  while (<SFILE>)
  {
    $_ = do_substitution($_);
    print TFILE $_;
  }

  close(TFILE);
  close(SFILE);
}

sub do_substitution
{
    my $what = shift;
    $what =~ s/\@Target\@/$TARGET/g;
    $what =~ s/\@Year\@/$V_YEAR/g;
    $what =~ s/\@IsoDate\@/$V_ISODATE/g;
    $what =~ s/\@User\@/$USER/g;
    $what =~ s/\@HeaderDir\@/$A_TARGET_DIR/g;
    return $what;
}

# {{{2 debug(message) - prints out _message_ as debug message
sub debug
{
  return if (!$A_DEBUG);
  print "@_\n";
}

# {{{2 verbose(message) - prints out _message_ if verbose is activated
sub verbose
{
  return if (!$A_VERBOSE);
  print "@_\n";
}

# {{{2 error(message) - prints out the _message_ and terminates the script
sub error
{
  print "ERROR: @_\n";
  exit(1);
}

# {{{2 get_mksource_template_dir
sub get_mksource_template_dir
{
  # first priority has a environment variable
  return $ENV{"MKSOURCE_TMPLDIR"} if (defined($ENV{"MKSOURCE_TMPLDIR"}) && (-d $ENV{"MKSOURCE_TMPLDIR"}));

  # next priority has a configuration entry
  debug("checking template dir $TMPLDIR");
  assert(defined($TMPLDIR));
  if (-e "$TMPLDIR")
  {
     debug("$TMPLDIR does exist");
     return $TMPLDIR;
  }

  # return the directory below if this directory exists
  my $ret = "/usr/local/etc/mksource_templates";
  debug("checking template dir $ret");
  return $ret if (-d $ret);

  # return the directory below if this directory exists
  my $ret = "/etc/mksource_templates"; return $ret if (-d $ret);

  error("no valid template directory TMPLDIR found");
}

# The get_config() function will return the %MKSOURCE_CONFIG
# hash that contains als relevant configuration settings of mksource. 
# {{{2 get_config()
sub get_config
{
    debug("reading configuration...");
    if (-e "$ENV{HOME}/.mksourceconfig")
    {
        read_config("$ENV{HOME}/.mksourceconfig");
        debug("TMPLDIR=$TMPLDIR");
    }
    else
    {
        debug(".mksourceconfig not found");
    }
}

# {{{2 read_config($filename)
sub read_config($)
{
    my $p_file = shift;
    debug("reading $p_file");
    open(CFGFILE, $p_file);
    while (<CFGFILE>)
    {
        debug("checking $_");
        if (/TMPLDIR\s*=\s*(.*)/)
        {
            $TMPLDIR=$1;
            debug("setting TMPLDIR to '$TMPLDIR' (source=$p_file)");
        }
    }
}

# {{{2 assert($expression) - aborts program if $expression is false
sub assert($)
{
    my $expression=shift;
    if (! $expression)
    {
        error("ASSERT failed! '$expression'");
    }
}

# {{{1 work functions

# Shows a list of all available templates.
# {{{2 list_templates - list all available templatex
sub list_templates 
{
    return list_templates_in_directory($TMPLDIR);
}

# {{{1 list_templates($directory) - find templates in $directory
#
# @returns undef if directory does not exist.
sub list_templates_in_directory($)
{
    my $directory = shift;
    my @templates = ();

    debug("list_templates($directory)");

    # check if directory name under $TMPLDIR exists    
    return undef if (!(-d $directory));

    foreach $filename (<$directory/*>)
    {
        next if (! -d $filename);
        $filename=~s/$directory\///;
        debug("found template $filename");
        push(@templates, $filename);
    }

    return @templates;
}


# if no template configuration has been found, mksource
# checks whether a $TMPLDIR/<template_name> subdirectory
# exists containing template files to convert.
#
# mksource does the substitution on every template file name
# itself and on the file content. I.e. a file named
# perl/@Target@.pl in $TMPLDIR will be converted to TargetName.pl
# in the output directory.
# {{{1 get_file_mapping($template_dir, $template_directory)
sub get_file_mapping ($$)
{
    my $template_dir = shift;
    my $template_name = shift;
    my %mapping;
   
    # check if directory name under $TMPLDIR exists    
    error("no template definition found") if (!(-d "$template_dir/$template_name"));

    foreach $filename (<$template_dir/$template_name/*>)
    {
        next if (-d $filename);
        debug("found template file $filename");
        $tmplfile = $targetfile = $filename;
        $tmplfile =~ s/$template_dir\///;
        $targetfile =~ s/$template_dir\/$template_name\///;
        debug("adding template file $tmplfile with target $targetfile");
        $mapping{$tmplfile} = $targetfile;
    }
    return %mapping;
};

# {{{1 Documentation

__END__

=head1 SYNOPSIS

mksource <options> [TARGET]

mksource - generate source files from templates

=head1 OPTIONS

  [TARGET]             Name of the target

  --template _string_
  -t _string_          Uses _string_ as template. This parameter is optional.
                       mksource uses the default template (cpp) if it is not set.
  --user _string_
  -u _string_          Uses _string_ as user name replacement instead of the
                       "LOGNAME" environment variable.
  --force
  -f                   Overwrite existing files in output directory

  --verbose
  -v                   Enables verbose output
  
  --debug
  -d                   Enables debug output

  --help
  -h                   Shows this help

  --list               List the available templates

mksource allows you to generate ready-to-use text files from predefined templates. During generation of the files, mksource will automatically replace predefined placeholders in the template by actual values, e.g. mksource replaces every occurence of @Target@ in the template by the name of the target.

Example:

  mksource -t cpp MyClass

generates the MyClass.cpp and MyClass.h files from it's template.

mksource will not overwrite existing files.

Substitutions:
--------------

mksource replaces the following tags by concrete values:

  @Target@    The target name (supplied as [TARGET] in command line)
  @Year@      The current 4-digit year (e.g. 2011)
  @IsoDate@   The current date in ISO8601 format (e.g. 2011-04-22)
  @HeaderDir@ The relative directory to which the header file will be written
  @User@      The user name (LOGNAME environment variable)

Template locations
------------------

The template directory is determined in the following order. On every step, mksource
checks whether the referenced directory exists. If yes, mksource uses this directory
as TMPLDIR. If not, the next step is executed:

1. Check if a TMPLDIR environment variable is set. If yes, use the string as TMPLDIR.

2. Check if a TMPLDIR configuration variable is set. If yes, use the string as TMPLDIR.

3. Use the directory ~/etc/mksource_templates.

4. Use the directory /user/local/etc/mksource_directories

5. Use the directory /etc/mksource_templates

The ~/.mksourceconfig
---------------------

The ~/.mksourceconfig is read on every startup and may contain configuration settings.

 # will read the templates from ~/.mksource_templates
 TMPLDIR = ~/.mksource_templates

Template configuration
----------------------

Mksource will try to find the $TMPLDIR/<template_name> directory and 
create source files for each template file found in this directory. 
  
The file name of the template files are subsituted according the substitution 
rules, i.e. a file named @Target@.cpp in the template directory will 
result in a <target_name>.cpp file in the output directory. 

Example:

Assuming you have a ~/etc/mksource_templates directory containing

    cpp/@Target@.cpp
    cpp/@Target@.h

templates file, mksource will generate

    MyClass.cpp
    MyClass.h

files in the output directory.

Bash completion
---------------

Source the mksource_completion.sh in the mksource installation directory
to activate bash completion. Ensure that mksource is in your $PATH directory.

mksource will automatically complete all command line options. Furthermore,
mksource will complete the --template argument with the list of available
arguments. See mksource --list.

