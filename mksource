#!/usr/bin/perl

use Getopt::Long;
use Pod::Usage;
use POSIX qw/strftime/;

# {{{1 Predefined templates

%MKSOURCE_TEMPLATES=
(
  "cpp" => {
             "cpp/cpp.cpp" => "\@TARGET\@.cpp",
             "cpp/cpp.h"   => "\@TARGET\@.h",
           },
  "cppunit" =>
           {
             "cpp/cppunit.cpp" => "\@TARGET\@.cpp",
             "cpp/cppunit.h"   => "\@TARGET\@.h",
           },
);

my $A_TEMPLATE_NAME = 'cpp';
my $A_VERBOSE = '';
my $A_HELP = '';
my $A_TARGET_DIR= '.';
my $A_DEBUG='';


my $V_YEAR=strftime("%Y", localtime());
my $V_ISODATE=strftime("%Y-%m-%d", localtime());
my $V_USER=$ENV{'LOGNAME'};

# {{{1 Argument evaluation

GetOptions(
  'template|t=s' => \$A_TEMPLATE_NAME,
  'help|h'       => \$A_HELP,
  'verbose|v'    => \$A_VERBOSE,
  'output|o'     => \$A_TARGET_DIR,
  'user|u'       => \$V_USER,
  'debug|d'      => \$A_DEBUG,
  );

$TARGET=shift @ARGV;
pod2usage(1) if ($A_HELP);
pod2usage(2) if (!$TARGET);

$V_SOURCE="cpp";

my $TMPLDIR="";

get_config();

my $TMPLDIR=get_mksource_template_dir();

die("unknown template '$A_TEMPLATE_NAME'") if (!defined($MKSOURCE_TEMPLATES{$A_TEMPLATE_NAME}));

while (($source, $target) = each(%{$MKSOURCE_TEMPLATES{$A_TEMPLATE_NAME}}))
{
  $target=~s/\@TARGET\@/$TARGET/g;
  verbose("generating $target from $source...");
  gen_source("$target", "$source");
}

# {{{1 FUNCTIONS

# {{{2 gen_source(target, source) - generate target file from source
sub gen_source
{
  my $target = shift @_;
  my $source = shift @_;

  die "target $A_TARGET_DIR/$target already exists" if (-e "$A_TARGET_DIR/$target");
  open(SFILE, "$TMPLDIR/$source") || error("source file not found $TMPLDIR/$source");
  open(TFILE, ">$A_TARGET_DIR/$target") || error("could not open $A_TARGET_DIR/$target for writing");

  while (<SFILE>)
  {
    s/\@Target\@/$TARGET/g;
    s/\@Year\@/$V_YEAR/g;
    s/\@IsoDate\@/$V_ISODATE/g;
    s/\@User\@/$V_USER/g;
    s/\@HeaderDir\@/$A_TARGET_DIR/g;
    print TFILE $_;
  }

  close(TFILE);
  close(SFILE);
}

# {{{2 debug(message) - prints out _message_ as debug message
sub debug
{
  return if (!$A_DEBUG);
  print "@_\n";
}

# {{{2 verbose(message) - prints out _message_ if verbose is activated
sub verbose
{
  return if (!$A_VERBOSE);
  print "@_\n";
}

# {{{2 error(message) - prints out the _message_ and terminates the script
sub error
{
  print "ERROR: @_\n";
  exit(1);
}

sub get_mksource_template_dir
{
  # first prioritz has a environment variable
  return $ENV{"MKSOURCE_TMPLDIR"} if (defined($ENV{"MKSOURCE_TMPLDIR"}) && (-d $ENV{"MKSOURCE_TMPLDIR"}));

  # next priority has a configuration entry
  debug("checking template dir $TMPLDIR");
  assert(defined($TMPLDIR));
  if (-e "$TMPLDIR")
  {
     debug("$TMPLDIR does exist");
     return $TMPLDIR;
  }

  # return the directory below if this directory exists
  my $ret = "/usr/local/etc/mksource_templates";
  debug("checking template dir $ret");
  return $ret if (-d $ret);

  # return the directory below if this directory exists
  my $ret = "/etc/mksource_templates"; return $ret if (-d $ret);

  error("no valid template directory TMPLDIR found");
}

=item get_config()
    The get_config() function will return the %MKSOURCE_CONFIG
    hash that contains als relevant configuration settings of mksource. 
=cut
sub get_config($)
{
    debug("reading configuration...");
    if (-e "$ENV{HOME}/.mksourceconfig")
    {
        read_config("$ENV{HOME}/.mksourceconfig");
        debug("TMPLDIR=$TMPLDIR");
    }
    else
    {
        debug(".mksourceconfig not found");
    }
}

sub read_config($)
{
    my $p_file = shift;
    debug("reading $p_file");
    open(CFGFILE, $p_file);
    while (<CFGFILE>)
    {
        debug("checking $_");
        if (/TMPLDIR\s*=\s*(.*)/)
        {
            $TMPLDIR=$1;
            debug("setting TMPLDIR to '$TMPLDIR' (source=$p_file)");
        }
    }
}

sub assert($)
{
    my $expression=shift;
    if (! $expression)
    {
        error("ASSERT failed! '$expression'");
    }
}
__END__

=head1 mksource

mksource - generate source files from templates

=head1 SYNOPSIS

mksource <options> [TARGET]

Options:

  [TARGET]             Name of the target

  --template _string_
  -t _string_          Uses _string_ as template. This parameter is optional.
                       mksource uses the default template (cpp) if it is not set.
  --user _string_
  -u _string_          Uses _string_ as user name replacement instead of the
                       "LOGNAME" environment variable.
  --verbose
  -v                   Enables verbose output
  
  --debug
  -d                   Enables debug output

  --help
  -h                   Shows this help

=head1 DESCRIPTION

Mksource allows you to generate ready-to-use text files from predefined templates. During generation of the files, mksource will automatically replace predefined placeholders in the template by actual values, e.g. mksource replaces every occurence of @Target@ in the template by the name of the target.

Example:

  mksource -t cpp MyClass

generates the MyClass.cpp and MyClass.h files from it's template.

Mksource will not overwrite existing files.

=head2 Substitutions

mksource replaces the following tags by concrete values:

  @Target@    The target name (supplied as [TARGET] in command line)
  @Year@      The current 4-digit year (e.g. 2011)
  @IsoDate@   The current date in ISO8601 format (e.g. 2011-04-22)
  @HeaderDir@ The relative directory to which the header file will be written
  @User@      The user name (LOGNAME environment variable)

=head2 Template locations

By default, mksource searches for the templates in the directory "/usr/local/etc/mksource_templates". This can be overwritten by setting the "MKSOURCE_TEMPLATE_DIR" environment variable.

=head2 Template configuration

=head2 Output directories

