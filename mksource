#!/usr/bin/perl

use Getopt::Long;
use Pod::Usage;
use POSIX qw/strftime/;

my $A_TEMPLATE_NAME = 'cpp';
my $A_VERBOSE = '';
my $A_HELP = '';
my $A_TARGET_DIR= '.';
my $A_DEBUG='';

my $V_TEMPLATE_DIR=get_mksource_template_dir();
error("template directory $V_TEMPLATE_DIR does not exist") if (! -e $V_TEMPLATE_DIR);

my $V_YEAR=strftime("%Y", localtime());
my $V_ISODATE=strftime("%Y-%m-%d", localtime());
my $V_USER=$ENV{'LOGNAME'};

# {{{1 Argument evaluation

GetOptions(
  'template|t=s' => \$A_TEMPLATE_NAME,
  'help|h'       => \$A_HELP,
  'verbose|v'    => \$A_VERBOSE,
  'output|o'     => \$A_TARGET_DIR,
  'user|u'       => \$V_USER,
  'debug|d'      => \$V_USER,
  );

$TARGET=shift @ARGV;
pod2usage(1) if ($A_HELP);
pod2usage(2) if (!$TARGET);

$V_SOURCE="cpp";

$SOURCE="$TEMPLATE_DIR/cpp.cpp";

# {{{1 Predefined templates

%TEMPLATES=
(
  "cpp" => {
             "cpp.cpp" => "\@TARGET\@.cpp",
             "cpp.h"   => "\@TARGET\@.h",
           },
  "cppunit" =>
           {
             "cppunit.cpp" => "\@TARGET\@.cpp",
             "cppunit.h"   => "\@TARGET\@.h",
           },
);

die("unknown template '$A_TEMPLATE_NAME'") if (!defined($TEMPLATES{$A_TEMPLATE_NAME}));

while (($source, $target) = each(%{$TEMPLATES{$A_TEMPLATE_NAME}}))
{
  $target=~s/\@TARGET\@/$TARGET/g;
  verbose("generating $target from $source...");
  gen_source("$target", "$source");
}

# {{{1 FUNCTIONS

# {{{2 gen_source(target, source) - generate target file from source
sub gen_source
{
  my $target = shift @_;
  my $source = shift @_;

  die "target $A_TARGET_DIR/$target already exists" if (-e "$A_TARGET_DIR/$target");
  open(SFILE, "$V_TEMPLATE_DIR/$source") || error("source file not found $V_TEMPLATE_DIR/$source");
  open(TFILE, ">$A_TARGET_DIR/$target") || error("could not open $A_TARGET_DIR/$target for writing");

  while (<SFILE>)
  {
    s/\@Target\@/$TARGET/g;
    s/\@Year\@/$V_YEAR/g;
    s/\@IsoDate\@/$V_ISODATE/g;
    s/\@User\@/$V_USER/g;
    s/\@HeaderDir\@/$A_TARGET_DIR/g;
    print TFILE $_;
  }

  close(TFILE);
  close(SFILE);
}

# {{{2 debug(message) - prints out _message_ as debug message
sub debug
{
  return if (!$A_DEBUG);
  print "@_\n";
}

# {{{2 verbose(message) - prints out _message_ if verbose is activated
sub verbose
{
  return if (!$A_VERBOSE);
  print "@_\n";
}

# {{{2 error(message) - prints out the _message_ and terminates the script
sub error
{
  print "ERROR: @_\n";
  exit(1);
}

sub get_mksource_template_dir
{
  # this is the default location
  my $ret = "/usr/local/etc/templates";

  # if the environment variable is not set, return the default
  # template location
  return $ret if (!defined($ENV{"MKSOURCE_TEMPLATE_DIR"}));

  # If the directory set in the environment variable does not exist,
  #  return the default template location.
  return $ret if (! -e $ENV{"MKSOURCE_TEMPLATE_DIR"});
  debug("MKSOURCE_TEMPLATE_DIR=" . $ENV{"MKSOURCE_TEMPLATE_DIR"});

  # return the template location, if exists
  return $ENV{"MKSOURCE_TEMPLATE_DIR"};
}

__END__

=head1 mksource

mksource - generate source files from templates

=head1 SYNOPSIS

mksource <options> [TARGET]

Options:

  [TARGET]             Name of the target

  --template _string_
  -t _string_          Uses _string_ as template. This parameter is optional.
                       mksource uses the default template (cpp) if it is not set.
  --user _string_
  -u _string_          Uses _string_ as user name replacement instead of the
                       "LOGNAME" environment variable.
  --verbose
  -v                   Enables verbose output
  
  --debug
  -d                   Enables debug output

  --help
  -h                   Shows this help

=head1 DESCRIPTION

Mksource allows you to generate ready-to-use text files from predefined templates. During generation of the files, mksource will automatically replace predefined placeholders in the template by actual values, e.g. mksource replaces every occurence of @Target@ in the template by the name of the target.

Example:

  mksource -t cpp MyClass

generates the MyClass.cpp and MyClass.h files from it's template.

Mksource will not overwrite existing files.

=head2 Substitutions

mksource replaces the following tags by concrete values:

  @Target@    The target name (supplied as [TARGET] in command line)
  @Year@      The current 4-digit year (e.g. 2011)
  @IsoDate@   The current date in ISO8601 format (e.g. 2011-04-22)
  @HeaderDir@ The relative directory to which the header file will be written
  @User@      The user name (LOGNAME environment variable)

=head2 Template locations

By default, mksource searches for the templates in the directory "/usr/local/etc/mksource_templates". This can be overwritten by setting the "MKSOURCE_TEMPLATE_DIR" environment variable.

=head2 Template configuration

=head2 Output directories


